В течение первых лет использования мной JavaScript, я чувствовал что-то неладное. Хоть я и мог писать сайты с помощью фреймворков, чего-то всё равно не хватало. Я боялся собеседований по JavaScript, потому что у меня не было четкого понимания основ.

За эти годы я сформировал "ментальную модель" JavaScript, которая дала мне уверенность. Здесь я делюсь **очень сжатой** её версией. Она структурирована как словарь, где каждой теме отведено несколько предложений.

По мере прочтения этого поста, попытайтесь держать вести оценку того, насколько *уверенно* вы чувствуете себя в каждой из тем. Я не буду осуждать вас, если вы прогадаете с некоторыми! В конце поста есть кое-что, что в этом случае вам поможет.

---

* **Значение**: Концепция значения немного абстрактное. Значение - это "вещь". Значение в JavaScript это то же самое, что и число в математике, или как точка в геометрии. Когда работает ваша программа, её мир полон значений. Числа, такие как `1`, `2`, и `420` - это значения, так же как и, например, это предложение: `"Коровы мычат"`. Однако, не *всё* является значением. Число - это значение, но оператор `if` - нет. Ниже мы разберем некоторые виды различных значений.
  - **Тип значения**: Существует несколько "типов" значений. Например, *числа (number)*, такие как `420`, *строки (strings)*, такие как `"Коровы мычат"`, *объекты (objects)*, и ещё некоторые другие типы. Вы можете узнать тип некоторого значения, вставив `typeof` перед ним. Например, `console.log(typeof 2)` выводит `"number"` (число).
  - **Примитивные значения**: Некоторые значения являются "примитивами". В них входят числа, строки, и другие. Особенность примитивных значений состоит в том, что вы не можете создавать их больше или изменять их каким-либо образом. Например, каждый раз, когда вы пишете `2` в своей программе, вы получаете *одно и то же* значение `2`. Вы не можете "создать" другое `2`, или заставить *значение* `2` "стать" `3`. Это также работает и для строк.
  - **`null` и `undefined`**: Это - два особенных значения. Они особеннные потому, что с ними нельзя производить большое количество действий -- они часто вызывают ошибки. Обычно, `null` означает, что значение отсутствует намеренно, а `undefined` означает, что это значение отсуствует ненамеренно. Но всё же, решение о выборе значения остается за программистом. Они существуют потому, что иногда лучше чтобы действие провалилось, чем продолжилось с отстуствующим значением.

* **Равенство**: Как и "значение", равенство это фундаментальное понятие в JavaScript. Мы говорим, что два значения равны, когда они... Вообще, я бы никогда так не сказал. Если два значения равны, это значит, что они и *являются* одним и тем же значением. Не два разных значения, а одно! Например, `"Коровы мычат" === "Коровы мычат"` и `2 === 2`, потому что `2` *и есть* `2`. Заметьте, что мы используем *три* знака равенства, чтобы показать это понятие равенства в JavaScript.
  - **Строгое равенство (Strict Equality)**: То же, что и выше.
  - **Ссылочное равенство (Referential Equality)**: То же, что и выше.
  - **Слабое равенство (Loose Equality)**: Ооо, а вот это уже другое! Слабое(свободное) равенство используется, когда мы пишем *два* знака равенства (`==`). Вещи могут быть *слабо равны*, даже если они ссылаются на *различные* значения, которые друг на друга похожи (такие как `2` и `"2"`). Слабое равенство было давно добавлено в JavaScript и с тех пор постоянно вызывает путаницу. Это понятие не фундаментально, но является частым источником ошибок. Вы можете как-нибудь на досуге узнать, как оно работает, но многие стараются этого избегать.

* **Литерал (Literal)**: Литерал - это когда вы ссылаетесь на значение, когда *буквально [literally]* пишете его в своей программе. Например, `2` - это *литерал числа*, а `"Банан"` - это *литерал строки*.

* **Переменная**: Переменная позволяет вам ссылаться на какое-то значение, используя имя. Например, `let message = "Коровы мычат"`. Теперь вы можете писать `message` вместо постоянного повторения предложения каждый раз в вашем коде. Вы можете затем изменить `message`, чтобы оно указывало на другое значение, например `message = "Я морж"`. Заметьте, это не изменяет *самого значения*, но только то, куда `message` указывает, как будто "провод". Он вёл к `"Коровы мычат"`, а теперь к `"Я морж"`.
  - **Область видимости (Scope)**: Было бы не круто, если бы могла быть только одна переменная `message` во всей программе. Вместо этого, когда вы объявляете переменную, она становится доступна в *части* вашей программы. Эта часть называется "область видимости". Есть некоторые правила, по которым работает область видимости, но обычно вы можете найти ближайшие скобки `{` и `}`, внутри которых вы объявили переменную. Этот "блок" кода и есть её область видимости.
  - **Назначение**: Когда мы пишем `message = "Я морж"`, мы изменяем переменную `message` так, чтобы она указывала на значение `"Я морж"`. Это - назначение, изменение или перезапись переменной.
  - **`let` против `const` против `var`**: Обычно нужно использовать `let`. Если вам нужно запретить изменение переменной, можно использовать `const`. (Некоторые кодовые базы и коллеги настолько педантичны и скрупулезны, что вынуждают вас использовать `const`, когда переменная назначается только один раз.) Избегайте `var`, если можете, потому что его правила области видимости сбивают с толку.
* **Объект**: Объект - это особенный тип значения в JavaScript. Крутая вещь в них это то, что в них могут быть связи с другими значениями. Например, объект `{flavor: "vanilla"}` имеет свойство `flavor`, которое указывает на значение `"vanilla"`. Думайте об объекте, как о "своем собственном" значении с торчащими из него "проводами".
  - **Свойство**: Свойство - это как "провод", торчащий из объекта и ведущий к какому-то значению. Оно может напомнить вам о переменных: у свойства есть имя (как `flavor`) и оно ведет к какому-то значению (например, `"vanilla"`). Но в отличие от переменной, свойство "живет" *внутри* самого объекта, а не в каком-то вместе в вашем коде (в области видимости). Свойство считается частью объекта -- но значение, на которое оно указывает - нет.
  - **Литерал объекта**: Литерал объекта - это способ создания объекта *буквально* напечатав его в своей программе, например `{}` или `{flavor: "vanilla"}`. Внутри `{}` может быть несколько пар `свойство: значение`, разделенных запятыми. Это позволяет нам указать, куда указывает "провод" свойства из нашего объекта.
  - **Идентичность объектов**: Мы ранее упоминали, что `2` *равняется* `2` (другими словами, `2 === 2`), потому что когда мы пишем `2`, мы "призываем" одно и то же значение. Но когда мы пишем `{}`, мы всегда получаем *разное* значвение! Поэтому `{}` *не равняется* другому `{}`. Попробуйте написать это в консоли: `{} === {}` (результат - false, т.е. ложь). Когда компьютер встречает `2` в нашем коде, он всегда выдает то же самое значение `2`. Однако, литералы объектов работают по другому: когда компьютер встречает `{}`, он *создает новый объект, который всегда является новым значением*. Так что такое идентичность объектов? Это ещё один термин для равенства, или "одинаковости" значений. Когда мы говорим "`a` и `b` имеют одну и ту же идентичность", мы имеем в виду, что "`a` и `b` указывают на *одно и то же* значение" (`a === b`). Когда мы говорим "`a` и `b` имеют разные идентичности", мы имеем в виду, что "`a` и `b` указывают на *разные* значения" (`a !== b`).
  - **Точечная запись (Dot Notation)**: Когда вам нужно прочитать свойство объекта или записать его, вы можете использовать точечную (`.`) запись. Например, если переменная `iceCream` указывает на объект, свойство `flavor` которого указывает на значение `"chocolate"`, запись `iceCream.flavor` выдаст вам значение `"chocolate"`.
  - **Скобочная запись (Bracket Notation)**: Иногда вы заранее не знаете, какое свойство вам нужно прочитать. Например, может иногда вам нужно прочитать `iceCream.flavor`, а иногда `iceCream.taste` *[taste - "вкус", flavor - синоним слова "вкус", примерно означающий "аромат" -- прим. перев.]*. Скобочная (`[]`) запись позволяет позволяет прочитать свойство, когда *его название* является переменной. К примеру, допустим, что `let ourProperty = 'flavor'`. Таким образом, `iceCream[ourProperty]` выдаст нам `"chocolate"`. Что интересно, мы можем использовать такой подход и при создании объектов: `{ [ourProperty]: "vanilla" }`.
  - **Мутации**: Мы можем сказать, что объект *мутирован*, когда кто-то изменяет его свойство так, чтобы оно указывало на другое значение. Например, если мы обозначим `let iceCream = {flavor: "vanilla"}`, мы можем затем *мутировать* этот объект с помощью `iceCream.flavor = "chocolate"`. Заметьте, что даже если мы использовали `const` для обозначения переменной `iceCream`, мы все равно можем изменять `iceCream.flavor`. Так происходит потому, что `const` предотвратит только переназначение *самой переменной* `iceCream`, но мы изменили (мутировали) *свойство* (`flavor`) объекта, на который указывала эта переменная. Некоторые люди вообще отказались от использования `const`, потому что находили его вводящим в заблуждение.
  - **Массив**: Массив - это объект, который представляет собой список вещей. Когда вы набираете *литерал массива*, такой как `["банановый", "шоколадный", "ванильный"]`, вы создаете объект, свойство `0` которого ведет к строке `"банановый"`, свойство `1`, которое ведет к значению `"шоколадный"`, и свойство `2`, ведущее к значению `"ванильный"`. Было бы довольно выматывающе писать `{0: ..., 1: ..., 2: ...}`, и поэтому массивы довольно полезные. Существует несколько встроенных способов для оперирования массивами, такие как `map`, `filter`, и `reduce`. Не расстраивайтесь, если `reduce` выглядит для вас запутанно -- все так считают.
  - **Прототип (Prototype)**: Что будет, если мы попытаемся прочитать несуществующее свойство? Например, `iceCream.taste` (но на самом деле свойство называется `flavor`). Вкратце, мы получим специальное значение `undefined`. Если отвечать более подробно, то у большинства объектов в JavaScript есть "прототип". О прототипе можно думать как о специальном "скрытом" свойстве на каждом объекте, которое определяет "где искать дальше". Так что если у объекта `iceCream` нет свойства `taste`, JavaScript поищет свойство `taste` на его прототипе, затем на прототипе *этого* объекта, и так далее, и выдаст `undefined` только в том случае, если дойдет до конца "цепочки прототипов" и не найдет `.taste`. Вы редко когда будете работать с этим механизмом напрямую, но он объясняет, почему у нашего объекта `iceCream` есть метод `toString`, хотя мы его не объявляли -- он идет из прототипа.

* **Функция**: Функция - это специальное значение, у которого есть только одно назначение: она обозначает *некоторый код в вашей программе*. Функции полезны, если вы не хотите писать один и тот же код множество раз. "Вызов" функции путём `sayHi()` говорит компьютеру выполнить код внутри функции, и затем вернуться обратно в то же место программы. Существует множество способов объявить функцию в JavaScript с небольшими различиями в них.
  - **Аргументы (или "параметры")**: Аргументы позволяют вам передать какую-либо информацию функции из того места, откуда вы её вызываете: `sayHi("Amelie")`. Внутри функции они работают аналогично переменным. Они называются либо "аргументами", либо "параметрами", в зависимости от того, с какой стороны вы читаете (объявление функции или вызов функции). Однако это различие в терминологии педантично, и на практике эти два термина используются взаимозаменяемо.
  - **Функциональные выражение**: Раньше мы присваивали переменной *строковое значение*, то есть `let message = "Я морж"`. Оказывается, переменной можно присвоить *функцию*, то есть `let sayHi = function() { }`. Здесь, всё что после `=` называется *функциональным выражением*. Оно дает нам специальное значение (функцию) которая представляет наш отрывок кода, так что мы можем вызвать его позже, если захотим.
  - **Объявление функций**: Становится утомительно каждый раз писать что-то вроде `let sayHi = function() { }`, поэтому вместо этого мы можем использовать более краткую форму: `function sayHi() { }`. Это называется *объявлением функции*. Вместо того, чтобы слева указывать название переменной, мы указываем его после ключевого слова `function`. Эти два стиля чаще всего взаимозаменяемы.
  - **"Поднятие" функций (Function Hoisting)**: Обычно, вы можете использовать переменную только после её объявления с помощью `let` или `const`. Это может раздражать в случае с функциями, потому что им может быть нужно вызывать другие функции, и очень сложно было бы отследить, какая функция какими используется и какая из них должна быть объявлена первее. Для удобства, когда (и только тогда!) вы используете *объявление функции*, порядок их объявления не важен, потому что они становятся "поднятыми". Это более простой способ сказать, что они автоматически перемещаются наверх области видимости. К тому времени, как вы их вызовете, они все будут объявлены.
  - **`this`**: Наверное, самый неправильно понятый концепт в JavaScript, `this` - это как специальный аргумент функции. Вы не передаете этот аргумент функции напрямую, наоборот, JavaScript сам устанавливает его, в зависимости от того *как вы вызовете* функцию. Например, при вызове с использованием точечной `.` записи -- например, `iceCream.eat()` -- функция получит специальное значение `this` из того, что было до `.` (в нашем случае, `iceCream`). Значение аргумента `this` внутри функции зависит от того, как функция *вызвана*, а не от того, как она объявлена. Вспомогательные функции, такие как `.bind`, `.call`, и `.apply` позволят вам лучше контроллировать значение `this`.
  - **Стрелочные функции**: Стрелочные функции похожи на функциональные выражения. Объявляют стрелочные функции следующим образом: `let sayHi = () => { }`. Они лаконичны и часто используются как однострочные функции. Стрелочные функции более ограничены, по сравнению с обычными функциями -- например, в них нет такого понятия как `this`. Когда вы пишете `this` внутри стрелочной функции, она использует `this` ближайшей "обычной" функции выше -- то же самое, что и при использовании аргумента или переменной, которая есть только в функции выше. На практике это означает, что люди используют стрелочные функции когда им нужен тот же самый `this` внутри них, что и в коде вокруг функции.
  - **Привязка (binding) функций**: Обычно, *привязка* функции `f` к конкретному значению `this` и аргументат означает создание *новой* функции, которая вызывает `f` с этими предопределенными значениями. В JavaScript есть специальная встроенная функция, которая называется `.bind`, но это также можно сделать и вручную. Привязка была популярным способом сделать так, чтобы вложенные функции "видели" то же самое значение `this`, что и внешние функции. Но теперь вместо этого можно использовать стрелочные функции, поэтому привязка сейчас используется не так часто.
  - **Стэк вызовов (Call Stack)**: Вызов функции - это как войти в комнату. Каждый раз, когда мы вызываем функцию, переменные внутри неё инициализируются заново. Так что каждый вызов функции это как *постройка* новой "комнаты" со своим кодом внутри и вход в неё. Переменные нашей функции "живут" в этой комнате. Когда мы возвращаемся (return) из этой функции, эта "комната" исчезает, вместе со всеми переменными. Вы можете представить эти комнаты как вертикальную "стопку" или "стэк"(stack) комнат -- **стэк вызовов**. Когда мы выходим из функции, мы возвращаемся к функции "ниже" этой в стэке вызовов.
  - **Рекурсия**: Рекурсия означает, что функция вызывает сама себя. Это полезно, когда вы хотите повторить то, что только что сделали в своей функции *снова*, но с другими аргументами(параметрами). Например, если вы пишете поисковый движок, который обходит всю сеть, ваша функция `collectLinks(url)` может сначала собрать все ссылки с какой-то страницы, а потом *вызвать себя же* для каждой *ссылки* до тех пор, пока не соберет все ссылки. Подводный камень состоит в том, что таким образом очень просто создать код, который никогда не закончит выполняться, потому что функция будет вечно вызывать саму себя. Если такое случится, JavaScript прекратит это с ошибкой "stack overflow"("переполнение стэка"). Эта ошибка так называется, потому что она означает, что в нашем стэке вызовов находится слишком много вызовов функций, и он буквально стал переполнен.
  - **Функция высшего порядка**: Функция высшего порядка - это функция, которая работает с другими функциями путём принятия их как аргументов, или возврата их в качестве результата (return). Поначалу это может звучать странно, но нужно помнить, что функции это значения, так что мы можем их всюду передавать -- так же как и с числами, строками и объектами. Этим стилем можно злоупотреблять, но такой стиль очень сложно регулировать.
  - **Обратный вызов (Callback)**: Callback это не термин из JavaScript, это скорее шаблон. Это когда вы передаете функцию как аргумент для другой функции, ожидая, что она *вызовет вашу функцию позже*. Вы ожидаете обратный вызов, перезвон ("call back"). Например, `setTimeout` принимает *callback*, и... вызывает его по истечении какого-либо установленного периода времени. Callback - это обычные функции, и когда мы говорим "callback", мы говорим только о своих ожиданиях/представлениях.
  - **Замыкание (Closure)**: Обычно, когда вы выходите из функции, все её значения "исчезают", потому что они больше ни для чего не нужны. Но что если мы обозначим функцию *внутри* другой функции? Тогда внутреннюю функцию можно будет вызвать позже и прочитать переменные *внешней* функции. На практике, это довольно полезно! Но чтобы это работало, переменные внешней функции должны где-то остаться. В этом случае, JavaScript заботится об удержании этих переменных, вместо того чтобы как обычно "забыть" их. Это называется "замыканием". Хоть замыкания часто считаются непонятым аспектом JavaScript, вы можете использовать их множество раз в день даже без осознания этого!

---

JavaScript сделан из подобных понятий и ещё многого другого. Я чувствовал себя неуверенно насчёт своих знаний в JavaScript, пока я не смог выстроить правильную "ментальную модель", и я хочу помочь следующему поколению разработчиков восполнить этот пробел поскорее.

Если вы хотите присоединиться ко мне, чтобы поглуюже окунуться в каждую из этих тем, у меня есть кое-что для вас. **[Just JavaScript](https://justjavascript.com/) это моя изощренная ментальная модель того, как работает JavaScript, и ещё там будут иллюстрации от [Maggie Appleton](https://illustrated.dev/)**. В отличие от этого поста, там всё происходит в более медленном темпе, так что вы можете уследить за всеми деталями.
